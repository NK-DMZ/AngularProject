# 一.快速上手
## 官方文档
https://angular.cn/ angular官网\
https://ng.ant.design/docs/introduce/zh ng-zorro官网\
https://www.tslang.cn/index.html ts官网\
https://yarnpkg.com/getting-started/migration yarn官网
## 项目基础架构
项目根目录下创建三个主要文件夹： 
- `public`：用于存放项目的静态资源
- `scripts` ：用于存放 webpack 的配置文件
- `src` ：用于存放项目的代码文件\
为了区分开 webpack 的开发和生产环境，因此需要两套配置文件，这两套配置有很多地方是共通的，为了代码优雅，可以使用第三方包 `webpack-merge` 来将公共配置分别导入两套文件，因此需要在 `scripts` 目录下创建三个文件：
- `webpack.common.js`：用于编写公共配置
- `webpack.dev.js`：用于编写开发环境配置
- `webpack.prod.js`：用于编写生产环境配置
## 区分环境
虽然都分开了配置，但是在公共配置中，还是可能会出现某个配置的某个选项在开发环境和生产环境中采用不同的配置，这个时候有两种选择：
- 分别在 dev 和 prod 配置文件中写一遍，common 中就不写了
- 设置某个环境变量，根据这个环境变量来判别不同环境
为了代码优雅性选择第二种方案，下载所需第三方包：
> `cross-env` ：统一配置Node环境变量
```
yarn add cross-env@7.03
```
> 不同操作系统设置环境变量的方式不一定相同，cross-env可以将其统一，比如Mac 电脑上使用 export NODE_ENV=development，而Windows 电脑上使用的是 set NODE_ENV=development
在 `scripts/config` 目录下新建 `env.js` 文件用于管理启动环境
> 在node中，全局变量 process 表示的是当前的node进程，process.env 包含着关于系统环境的信息，NODE_ENV 是用户一个自定义的变量，该变量会在下面配置启动命令时配上，这里先写上
```js
const isDevelopment = process.env.NODE_ENV === 'development'
const isProduction = process.env.NODE_ENV === 'production'
module.exports = {  isDevelopment,  isProduction}
```
## 管理公共常量
在 `scripts` 目录下新建 `constant.js` 文件，用于统一管理公共常量
首先先写公共项目根路径和启动端口及IP
```js
// scripts/constant.js
const path = require('path')
const PROJECT_PATH = path.resolve(__dirname, '../')   // 项目根路径
const SERVER_HOST = '127.0.0.1'
const SERVER_PORT = 3000
export {
  PROJECT_PATH,
  SERVER_HOST,
  SERVER_PORT,
}
```
webpack 配置的路径一般要求绝对路径写法，所以项目中往往会如下这样配置，可读性不佳
```js
module.exports = {
  entry: {
    app: path.resolve(__dirname, '../../src/index.js')
  },
  ...
}
```
使用配置的常量则可以如下配置
```js
module.exports = {
  entry: {
     app: path.resolve(PROJECT_PATH, './src/index.tsx'),       
  },
  ...
}
```
## 创建新文件
**Component(组件):**\
npm run ng g component ./core/my-new-component\
**Directive(指令):**\
npm run ng g directive ./core/my-new-directive\
**Pipe(管道):**\
npm run ng g pipe ./core/my-new-pipe\
**Service(服务):**\
npm run ng g service ./core/my-new-service\
**Class(类):**\
npm run ng g class ./core/my-new-class\
**Interface(接口):**\
npm run ng g interface ./core/my-new-interface\
**Enum(枚举):**\
npm run ng g enum ./core/my-new-enum\
**Module(模块):**\
npm run ng g module ./core/my-module\
这里说明一下，路由module没有创建指令，目前在study项目中创建的一个完整的组件包含组件（4个文件）、模块（1个文件）、路由模块（1个文件）。如图示：\
![](./image/1.1.module%E6%8C%87%E4%BB%A4.png)\
其中.html是写页面的，.less是写样式的，.ts是写页面逻辑的，-routing.module.ts是写路由的，module是写模块引入的，.spec.ts是测试文件。

# 二.生命周期函数
官网详细说明可以查阅 https://angular.cn/guide/lifecycle-hooks \
Angular 会按以下顺序调用钩子方法：\
| 序号 | 钩子方法 | 详细信息 |
| :------| ------: | :------: |
| 1 | ngOnChanges           | 当输入或输出绑定值更改时。  |
| 2 | ngOnInit              | 在第一个 ngOnChanges 之后。|
| 3 | ngDoCheck             | 开发人员的自定义变更检测。  |
| 4 | ngAfterContentInit    | 组件内容初始化后。         |
| 5 | ngAfterContentChecked | 在每次检查组件内容之后。    |
| 6 | ngAfterViewInit       | 在组件的视图被初始化之后。  |
| 7 | ngAfterViewChecked    | 在每次检查组件视图之后。    |
| 8 | ngOnDestroy           | 就在指令被销毁之           |
|   |                       |                           |
	
上表如果不够直观可以看看下面项目中的输出展示，当我们启动页面时，生命周期依次执行。
![](./image/2.1.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E4%BE%9D%E6%AC%A1%E6%89%A7%E8%A1%8C.png)\
如果我们修改页面数据再来看看执行了哪些生命周期函数：
![](./image/2.2.%E4%BF%AE%E6%94%B9%E5%80%BC%E6%97%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C.png)
由程序执行可知ngDoCheck 方法、ngAfterContentChecked 方法、ngAfterViewChecked 方法在数值改变时会被执行。
使用比较频繁的函数有：
ngOnInit函数，用于数据请求；ngAfterViewInit函数，常用于echarts实例初始化；ngOnDestroy函数，用于指令中echarts实例的销毁。

# 三.数据使用
## 标题  **[title]**
``` 
public student: string = "student!";

<div [title]="student">
  <p>小茗同学</p>
</div>
```
展示的效果：当鼠标悬停在div上时会有提示，提示内容为"student!"。

## 字符串模板解析  **[innerHTML]**
当我们想把字符串解析的时候一般会想到下面这种使用方法:
```
public htmlContent: string = "<h5>这是h5标签</h5>";

<div>
  {{htmlContent}}
</div>
```
但是这种使用方法达不到我们所需要的效果。这时我们可以使用[innerHTML]对html元素进行解析。
```
<span [innerHTML]="htmlContent"></span>
<p [innerHTML]="htmlContent"></p>
<h5 [innerHTML]="htmlContent"></h5>
<textarea [innerHTML]="htmlContent"></textarea>
```
由图可见如果仅仅只是通过{{}}语法是无法让浏览器解析出html模板的，我们无论是用p标签、span标签还是h5标签都会解析成变量中的h5标签，而textarea解析的会带有自己的格式。

![](./image/2.3.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90.jpg)\

## 图片引入   **[src]**
```
public imgUrl: string = 'http://bpic.588ku.com/back_pic/03/52/10/03579335225368f.jpg!/fh/300/quality/90/unsharp/true/compress/true'

<img [src]="imgUrl" alt="">
```

## 双向数据绑定  **[(ngModel)]**
1.app.module.ts文件中引入:
```
import { FormsModule } from '@angular/forms';
```
2.app.module.ts文件中在imports进行声明:添加 FormsModule
3.html使用
```
<input type="text" [(ngModel)] = 'keywords'> {{keywords}}
```
![](./image/2.6.%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.jpg)

## class类  **[ngClass]**
[ngClass]="{'red':(key===0),'grey':(key===1),'orange':(key===2),'lawngreen':(key===3),'sienna':(key===4)}"\
'red'是类名，后面的(key===0)其实就是TRUE和FALSE。
```
<ul *ngFor="let item of arrlist;let key = index;" [ngClass]="{'red':(key===0),'grey':(key===1),'orange':(key===2),'lawngreen':(key===3),'sienna':(key===4)}">
    <li>{{key+1}}---{{item}}</li>
</ul>
```

## style样式  **[ngStyle]**
效果和class类似
```
<p [ngStyle]="{'color':attrColor}">ngStyle使用</p>

下面代码不会生效
style = "'color':red"
<p [ngStyle]="{style}">ngStyle使用</p>
```

## *ngFor数据循环
*ngFor用于数组的循环
```
// 定义数组
public arr: string[] = [
  '我不是枪神',
  '长津湖',
  '这个杀手不太冷',
  '熊出没',
  '不要忘记我爱你',
];

<ul>
  <p>带索引</p>
  <li *ngFor="let item of arr;let key = index" class="ulli">{{key}}---{{item}}</li>
</ul>
```
![](./image/2.4.%E6%95%B0%E6%8D%AE%E5%BE%AA%E7%8E%AF.jpg)

## *ngIf和[hidden]选择性展示
ngif与hidden的区别和v-if与v-show的区别一样，一个是直接让dom节点消失，一个是让dom隐藏。
### ngif使用
```
<button (click)="changeFlag()">改变图片显示</button> <br><br>
<img *ngIf="flag" src="../../../assets/images/boolean (1).png" alt="">
<img *ngIf="!flag" src="../../../assets/images/boolean (2).png" alt="">
```
![](./image/2.7.ngif%E5%9B%BE%E7%89%87%E4%BD%BF%E7%94%A81.jpg)
![](./image/2.7.ngif%E5%9B%BE%E7%89%87%E4%BD%BF%E7%94%A82.jpg)
### [hidden]使用
```
<button (click)="changeHidden()">改变hidden显示</button> <br><br>
<p [hidden]="hidden">hidden</p>
```
![](./image/2.7.hidden%E4%BD%BF%E7%94%A81.jpg)
![](./image/2.7.hidden%E4%BD%BF%E7%94%A82.jpg)

## ng表达式不能出现的
NG表达式中禁止出现new关键字,NG表达式中JSON是undefined
![](./image/2.5.%E4%B8%8D%E8%83%BD%E5%87%BA%E7%8E%B0.jpg)

# 四.DOM操作
## 原生js操作dom
```
<div id="domHtml">
  这是原生JavaScript对dom进行操作
</div>

let oBox = document.getElementById('domHtml');
console.log(oBox.innerHTML);
oBox.style.color = "red"
```
![](./image/4.1.ID%E8%8E%B7%E5%8F%96dom.jpg)

## 被angular操作过的DOM元素
无法在ngOnInit生命周期获取
```
let oBox1: any = document.getElementById('box1');
console.log(oBox1.innerHTML);
oBox.style.color = "blue"
```
![](./image/4.2.%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96dom.jpg)

可以在ngAfterViewInit生命周期正常使用
```
let oBox1: any = document.getElementById('box1');
console.log(`这是domAction中的oBox1:${oBox1.innerHTML}`);
oBox1.style.color = "blue"
```
![](./image/4.3.%E5%9C%A8ngAfterViewInit%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E4%BD%BF%E7%94%A8.jpg)

## 利用 ViewChild 实现操作dom
1.引入 ViewChild 
```
import { Component, OnInit, ViewChild } from '@angular/core';
```
2.在html页面使用
```
<div #myBox>
  <h3>这是利用 ViewChild 实现操作dom</h3>
  这是一个dom节点
</div>
```
3.获取dom节点
```
@ViewChild('myBox') myBox: any;
```
4.利用ViewChild进行操作
```
this.myBox.nativeElement.style.width = '300px'
this.myBox.nativeElement.style.height = '80px'
this.myBox.nativeElement.style.background = 'yellow'
```
![](./image/4.4.ViewChild%E8%8E%B7%E5%8F%96dom.jpg)

## 通过ViewChild操作子组件
1.html使用
```
<app-dom-actions-help #domActionChild>
  <h3>这是操作子组件</h3>
</app-dom-actions-help>
<button (click)="getClick()">点击获取子组件的方法</button>
```
2.获取dom节点
```
@ViewChild('domActionChild') domActionChild: any;
```
3.调用子组件的方法
```
getClick() {
  this.domActionChild.domActions()
}
```
![](./image/4.5.%E6%93%8D%E4%BD%9C%E5%AD%90%E7%BB%84%E4%BB%B6.jpg)

# 五.事件
## 普通事件
html使用
```
<p><button (click)="run()">点击触发run方法</button></p>
```
ts中调用
```
run(){
  alert('事件run方法被触发')
}
```
![](./image/5.1.%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91.jpg)

## 表单事件与事件对象
html使用
```
<p>{{keydownValueOne}}</p>
<p>{{keydownValueTwo}}</p>
<input type="text" (keydown)="keydown()" placeholder="直接修改属性值">
<input type="text" (keyup)="keyupEvent($event)" placeholder="获取事件dom">
```
ts中调用
```
keydown(){
  this.keydownValueOne='keydownValue进行修改'
}
keyupEvent(e:any){
  console.log(e);
  if(e.keyCode == 13){
    console.log('按了一下回车');      
  }else{
    // e.target 获取dom对象
    // 获取对象的值
    console.log(e.target.value);
  }
}
```
函数调用前\
![](./image/5.2.%E4%BA%8B%E4%BB%B6%E8%B0%83%E7%94%A8%E5%89%8D.jpg)

在第一个输入框修改值会触发keydown函数\
![](./image/5.3.%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%90%8E.jpg)

在第二个对话框修改内容会触发keyupEvent函数，能清晰打印出e.target
![](./image/5.4.%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.jpg)

## 通过事件对象获取dom修改样式
html使用
```
<p><button (click)="changeColor($event)">修改颜色</button></p>
```
ts中调用
```
changeColor(event:any){
  let dom:any = event.target;
  dom.style.color = 'blue'
}
```
![](./image/5.5.%E9%80%9A%E8%BF%87%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96dom%E8%BF%9B%E8%A1%8C%E4%BF%AE%E6%94%B9.jpg)

# 六.组件引用
angularAntdEcharts项目对这一知识点有详细说明




